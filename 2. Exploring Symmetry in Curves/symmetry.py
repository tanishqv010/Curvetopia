# -*- coding: utf-8 -*-
"""Curvetopia

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ZL4JkqX7e9FCS6UppqX0U2l0X9fhZt-

# 2. Exploring Symmetry in Curves

### Downloading Neccessary Libraries
"""

# !pip install opencv-python-headless numpy matplotlib scipy scikit-image

"""### Importing Necessary Libraries"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import splprep, splev
from skimage.measure import find_contours, approximate_polygon

"""### Inter conversion of Image and Polylines"""

def image_to_polyline(image_path):
    img = cv2.imread(str(image_path), 0)
    _, binary_img = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
    contours = find_contours(binary_img, 0)
    paths_XYs = []
    for contour in contours:
        polygon1 = approximate_polygon(contour, tolerance=1)
        paths_XYs.append(polygon1)
    return paths_XYs, img.shape

def read_csv(csv_path):
    np_path_XYs = np.genfromtxt(csv_path, delimiter=',')
    path_XYs = []
    for i in np.unique(np_path_XYs[:, 0]):
        npXYs = np_path_XYs[np_path_XYs[:, 0] == i][:, 1:]
        XYs = []
        for j in np.unique(npXYs[:, 0]):
            XY = npXYs[npXYs[:, 0] == j][:, 1:]
            XYs.append(XY)
        path_XYs.append(XYs)
    return path_XYs

def polyline_to_csv(paths_XYs):
    for path_XYs in paths_XYs:
        for XY in path_XYs:
            X_coords = XY[:, 0]
            Y_coords = XY[:, 1]
            plt.plot(X_coords, Y_coords)
    plt.axis('off')
    plt.savefig('image.png')
    plt.close()
    return 'image.png'

"""### Smoothening of Polylines"""

def smooth_polyline(polyline, smoothing_factor=0.1):
    points = polyline.reshape(-1, 2).astype(np.float32)
    if len(points) < 4:
        return points
    t = np.linspace(0, 1, len(points))
    try:
        tck, _ = splprep([points[:, 0], points[:, 1]], u=t, s=smoothing_factor)
        new_t = np.linspace(0, 1, len(points))
        smooth_points = splev(new_t, tck)
        smoothed_polyline = np.vstack(smooth_points).T
    except Exception:
        smoothed_polyline = points
    return smoothed_polyline

"""### Utility Functions"""

def calculate_bounding_rect_centroid(points):
    points = np.array(points, dtype=np.float32)
    x, y, w, h = cv2.boundingRect(points)
    return np.array([x + w / 2, y + h / 2])

def align_points(pts1, pts2):
    centroid1 = calculate_bounding_rect_centroid(pts1)
    centroid2 = calculate_bounding_rect_centroid(pts2)
    return pts2 + (centroid1 - centroid2), centroid1, centroid2

def calculate_mean_distance(pts1, pts2):
    distances = [np.min(np.linalg.norm(pts2 - p1, axis=1)) for p1 in pts1]
    return np.mean(distances)

def rotate_points(points, angle, center):
    angle_rad = np.deg2rad(angle)
    rotation_matrix = np.array([
        [np.cos(angle_rad), -np.sin(angle_rad)],
        [np.sin(angle_rad), np.cos(angle_rad)]
    ])
    return np.dot(points - center, rotation_matrix.T) + center

def calc_mean_distance(pts1, pts2, center, angle=0):
    pts1_rotated = rotate_points(pts1, angle, center)
    pts2_rotated = rotate_points(pts2, angle, center)
    reflected_pts2 = pts2_rotated.copy()
    reflected_pts2[:, 0] = 2 * center[0] - pts2_rotated[:, 0]
    reflected_pts2, centroid1, centroid2 = align_points(pts1_rotated, reflected_pts2)
    return calculate_mean_distance(pts1_rotated, reflected_pts2)

"""### Detection of Symmetry"""

def detect_symmetries(polylines, image_shape):
    center_x = image_shape[1] // 2
    center_y = image_shape[0] // 2
    center = (center_x, center_y)
    angles = range(0, 360)
    all_polylines = np.concatenate(polylines)
    mean_distances = [calc_mean_distance(all_polylines, all_polylines, center, angle) for angle in angles]
    perf = min(mean_distances)
    rg = max(mean_distances) - min(mean_distances)
    if perf > 10:
        return {}
    return {angle: mean_distances[angle] <= perf + rg * 0.02 for angle in angles}

"""### Plotting Lines of Symmetry"""

def plot_results(image_path, angles, center):
    image = cv2.imread(image_path)
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    plt.imshow(image_rgb)
    plt.axis('off')
    for angle in angles:
        angle_rad = np.deg2rad(angle)
        x_offset = np.cos(angle_rad) * max(image_rgb.shape[1], image_rgb.shape[0])
        y_offset = np.sin(angle_rad) * max(image_rgb.shape[1], image_rgb.shape[0])
        plt.plot([center[0] - x_offset, center[0] + x_offset],
                 [center[1] - y_offset, center[1] + y_offset],
                 'r-', linewidth=2)
    plt.show()

"""### Driver Code"""

if __name__ == '__main__':
    n = int(input("Enter 1 to input the image and 2 to input the csv: "))
    if n == 1:
        image_path = input("Enter the image path: ")
    else:
        poly_path = input("Enter the csv path: ")
        polylines = read_csv(poly_path)
        image_path = img_from_polylines(polylines)
    polylines, image_shape = image_to_polyline(image_path)
    symmetries = detect_symmetries(polylines, image_shape)
    angles = [i for i in symmetries.keys() if symmetries[i]]
    moments = cv2.moments(cv2.imread(image_path, cv2.IMREAD_GRAYSCALE))
    center_x = moments['m10'] / moments['m00']
    center_y = moments['m01'] / moments['m00']
    center = (center_x, center_y)
    plot_results(image_path, angles, center)